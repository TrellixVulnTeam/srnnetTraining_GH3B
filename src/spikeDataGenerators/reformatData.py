# A.Lonsberry
# November 2016
#
# DESCRIPTION
#   Here I am going to implement methods to alter the format of data. Some of the data I create in other files is not
#   in the format that works directly in a brian simulation. Here are methods to convert and manipulated any generated
#   data.

import matplotlib.pyplot as plt
import numpy

# I had a difficult time getting things to import, so now I have however, go about fixing this by going up a directoy
# which I think I can do in the following way.
import os
import sys
import pickle
sys.path.append(os.path.abspath("../"))


def convertSpikeListsToBrainInput(spikeLists, combineData=False, timeInjection=5.):
    """
    DESCRIPTION
    The methods in spikeDataGenerators/analogToSpikes.py have methods that produce spikes in list form. The typical
    output is a list of lists, [ sublist1, sublist2, ... sublistn], where each subList is a list of the spike times
    generated by some signal. Most typically this list of lists is essentially is the time-varying input of multiple
    inputs feeding at the same time into a network or driving a network.

    In my most common code, input neruons are essentially are just defined by a neuron index and time of spikes. Thus
    we need to take these list of lists and turn into one 2D numpy.array() where we have numpy.array((nueron-ID, spike-
    time), (neuron-ID, spike-time), ... ) where the array is sorted by time in ascending order. Thus we want to take
    these lists of lists and convert into this form.

    This function is more generic, it can handle lists of lists of lists. In these more expansive scenarios, we will
    find all the list of lists and turn them into a 2D numpy.array(). The rest of the list structure will remain
    unchanged.

    We also have ways to combine list of lists with other lists of lists. This is the scenario in which we will want
    to combine multiple datasets together to form one larger dataset. We also have the option of putting empty inter
    mediate time between each. So where after the first processin we have [ 2D-array, 2D-array, ... ] now we will have
    2D-array. If 2 or more 2D-arrays are stored in the same list, then they will be combines into one with intermediate
    time as required.

    :param spikeLists: list of list [ [.2, .4, 19.1], .... ] where each sublist is the spike times for a neuron or input
           signal. This can handle list of lists of lists (see more details in the description)
    :return: list of nX2 numpy.array(), where the first column has the signal ID, the second column has spike time, and
             the whole thing is  sorted by time in asscending order. (see details above for more information)
    """

    # First I have function that will take in a list of lists and convert to correct numpy.array() structure.
    def altSpikeStruct(listOfSpikeLists):
        # Find how many spikes in total we will have
        numbInds = 0
        for someList in listOfSpikeLists:
            numbInds += len(someList)
        # Create the full numpy array, and then fill it
        outArray = numpy.zeros((numbInds, 2))
        index = 0
        for i,someList in enumerate(listOfSpikeLists):
            outArray[index:index+len(someList), 0] = i
            outArray[index:index+len(someList), 1] = numpy.asarray(someList)
            index += len(someList)
        # Now sort the output by spike times
        outArray = outArray[outArray[:,1].argsort()]
        return outArray

    # Now I will define a function so I can recurse into the spikeLists thing
    def incrementInside(inputList):
        if isinstance(inputList[0],list):
            if isinstance(inputList[0][0],list):
                # If we have a list within a list, we are not yet deep enough, though we will have to begin to iterate
                subList = []
                for i in range(len(inputList)):
                    subList.append(incrementInside(inputList[0]))
                return subList
            else:
                # We are deep enough
                return altSpikeStruct(inputList)
        else:
            # If we are deep enough we call the spike-times to numpy.array function
            return altSpikeStruct([inputList])

    # Now we will apply the recursion which will inherently apply the conversion of list of lists to 2D numpy.array or
    # 2D numpy.arrays.
    output = incrementInside(spikeLists)

    # Now we also have to handle the situation where we have to combine multiple input data (ie. multiple 2D numpy.array
    # inputs). If we have a sublist like ...[2D numpy.array, 2D numpy.array, .... ] we will combine these, fix the times
    # and add time between them as desired.
    if combineData:

        # First we define the method that will be used to stick 2D numpy.arrays together.
        def combineSpikeArray(listOfSpikeArrays):
            # Find out how many spikes in total we will need to include
            totalNumbSpikes = 0
            for aArry in listOfSpikeArrays:
                totalNumbSpikes += aArry.shape[0]
            # Now make a new numpy.array
            outArray = numpy.zeros((totalNumbSpikes,2))
            # Iteratively add all the seperate arrays together
            index = 0
            timeToAdd = 0.
            for i, someArray in enumerate(listOfSpikeArrays):
                # Add the time to someArray
                someArray[:,1] += timeToAdd + timeInjection
                # Now add to the final output addary
                outArray[index:index + someArray.shape[0], :] = someArray
                # Fix index things
                index += someArray.shape[0]
                timeToAdd = someArray[-1,1]
            return outArray

        # Now we have to define the method that will recursively operate of the list of lists ... of 2D numpy.arrays.
        def recurseAgain(inputList):
            if isinstance(inputList[0], list):
                subList = []
                for dumy in inputList:
                    subList.append(recurseAgain(dumy))
                return subList
            else:
                return combineSpikeArray(inputList)

        output = recurseAgain(output)

    return output




########################################################################################################################
# TESTING METHDOS
########################################################################################################################
# Some the methods win.

if __name__ == "__main__":

    import random

    # TESTING convertSpikeListsToBrainInput()
    # Test 1 : a spike list of spike times
    spikeList = []
    for i in range(5):
        spikeList.append(random.random())
        if len(spikeList)>2:
            spikeList[-1] = spikeList[-1] + spikeList[-2]
    outputSpikesFormatted = convertSpikeListsToBrainInput(spikeList)
    print("\n")
    print(outputSpikesFormatted )

    # Test 2: two spike lists in one list
    spikeList = []
    for i in range(2):
        subSpikeList = []
        for j in range(5):
            subSpikeList.append(random.random())
            if len(subSpikeList)>2:
                subSpikeList[-1] = subSpikeList[-1] + subSpikeList[-2]
        spikeList.append(subSpikeList)
    outputSpikesFormatted = convertSpikeListsToBrainInput(spikeList)
    print("\n")
    print(outputSpikesFormatted)

    # Test 3: Two spike lists in a bigger list.
    spikeList = [spikeList, spikeList, spikeList]
    outputSpikesFormatted = convertSpikeListsToBrainInput(spikeList)
    print("\n")
    print(outputSpikesFormatted)

    # Test 4: Now we want to combine 2D arrays!
    outputSpikesFormatted = convertSpikeListsToBrainInput(spikeList, combineData=True, timeInjection=5.)
    print("\n")
    print(outputSpikesFormatted)

