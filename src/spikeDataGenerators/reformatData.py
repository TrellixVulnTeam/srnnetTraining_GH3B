# A.Lonsberry
# November 2016
#
# DESCRIPTION
#   Here I am going to implement methods to alter the format of data. Some of the data I create in other files is not
#   in the format that works directly in a brian simulation. Here are methods to convert and manipulated any generated
#   data.

import matplotlib.pyplot as plt
import numpy
import numpy.random

# I had a difficult time getting things to import, so now I have however, go about fixing this by going up a directoy
# which I think I can do in the following way.
import os
import sys
import pickle
sys.path.append(os.path.abspath("../"))


def convertSpikeListsToBrainInput(spikeLists, combineData=False, timeInjection=5.):
    """
    DESCRIPTION
    The methods in spikeDataGenerators/analogToSpikes.py have methods that produce spikes in list form. The typical
    output is a list of lists, [ sublist1, sublist2, ... sublistn], where each subList is a list of the spike times
    generated by some signal. Most typically this list of lists is essentially is the time-varying input of multiple
    inputs feeding at the same time into a network or driving a network.

    In my most common code, input neurons are essentially are just defined by a neuron index and time of spikes. Thus
    we need to take these list of lists and turn into one 2D numpy.array() where we have numpy.array((nueron-ID, spike-
    time), (neuron-ID, spike-time), ... ) where the array is sorted by time in ascending order. Thus we want to take
    these lists of lists and convert into this form.

    This function is more generic, it can handle lists of lists of lists. In these more expansive scenarios, we will
    find all the list of lists and turn them into a 2D numpy.array(). The rest of the list structure will remain
    unchanged.

    We also have ways to combine list of lists with other lists of lists. This is the scenario in which we will want
    to combine multiple data sets together to form one larger data set. We also have the option of putting empty inter
    mediate time between each. So where after the first processing we have [ 2D-array, 2D-array, ... ] now we will have
    2D-array. If 2 or more 2D-arrays are stored in the same list, then they will be combines into one with intermediate
    time as required.

    NOTE: the 'combineData' function may not be all that useful as there will be other methods (likely here in this .py
    file) to combine the numpy.arrays in a more general ways and allow more control and more detailed output.

    :param spikeLists: list of list [ [.2, .4, 19.1], .... ] where each sublist is the spike times for a neuron or input
           signal. This can handle list of lists of lists (see more details in the description)
    :return: list of nX2 numpy.array(), where the first column has the signal ID, the second column has spike time, and
             the whole thing is  sorted by time in asscending order. (see details above for more information)
    """

    # First I have function that will take in a list of lists and convert to correct numpy.array() structure.
    def altSpikeStruct(listOfSpikeLists):
        # Find how many spikes in total we will have
        numbInds = 0
        for someList in listOfSpikeLists:
            numbInds += len(someList)
        # Create the full numpy array, and then fill it
        outArray = numpy.zeros((numbInds, 2))
        index = 0
        for i,someList in enumerate(listOfSpikeLists):
            outArray[index:index+len(someList), 0] = i
            outArray[index:index+len(someList), 1] = numpy.asarray(someList)
            index += len(someList)
        # Now sort the output by spike times
        outArray = outArray[outArray[:,1].argsort()]
        return outArray

    # Now I will define a function so I can recurse into the spikeLists thing
    def incrementInside(inputList):
        if isinstance(inputList[0],list):
            if isinstance(inputList[0][0],list):
                # If we have a list within a list, we are not yet deep enough, though we will have to begin to iterate
                subList = []
                for i in range(len(inputList)):
                    subList.append(incrementInside(inputList[0]))
                return subList
            else:
                # We are deep enough
                return altSpikeStruct(inputList)
        else:
            # If we are deep enough we call the spike-times to numpy.array function
            return altSpikeStruct([inputList])

    # Now we will apply the recursion which will inherently apply the conversion of list of lists to 2D numpy.array or
    # 2D numpy.arrays.
    output = incrementInside(spikeLists)

    # Now we also have to handle the situation where we have to combine multiple input data (ie. multiple 2D numpy.array
    # inputs). If we have a sublist like ...[2D numpy.array, 2D numpy.array, .... ] we will combine these, fix the times
    # and add time between them as desired.
    if combineData:

        # First we define the method that will be used to stick 2D numpy.arrays together.
        def combineSpikeArray(listOfSpikeArrays):
            # Find out how many spikes in total we will need to include
            totalNumbSpikes = 0
            for aArry in listOfSpikeArrays:
                totalNumbSpikes += aArry.shape[0]
            # Now make a new numpy.array
            outArray = numpy.zeros((totalNumbSpikes,2))
            # Iteratively add all the seperate arrays together
            index = 0
            timeToAdd = 0.
            for i, someArray in enumerate(listOfSpikeArrays):
                # Add the time to someArray
                someArray[:,1] += timeToAdd + timeInjection
                # Now add to the final output addary
                outArray[index:index + someArray.shape[0], :] = someArray
                # Fix index things
                index += someArray.shape[0]
                timeToAdd = someArray[-1,1]
            return outArray

        # Now we have to define the method that will recursively operate of the list of lists ... of 2D numpy.arrays.
        def recurseAgain(inputList):
            if isinstance(inputList[0], list):
                subList = []
                for dumy in inputList:
                    subList.append(recurseAgain(dumy))
                return subList
            else:
                return combineSpikeArray(inputList)

        output = recurseAgain(output)

    return output


def combineInputSequencesNonRandom(spikeLists, timeInjection=5., sequence=[]):
    """
    DESCRIPTION
    We may want to combine spike sequences in a very specific way. This is a generic fuction that does so. This function
    will take input that is already ready for brian (as I have been implementing it) where the basic unit is a 2d numpy
    array with each row bing a different spike. The first column has the index of the neuron/signal, and the second
    column has the spike time. These arrays should be sorted already by time in an ascending manner.

    Here we specifically have a list of the 2D numpy.arrays and then given some sequence, we reorder them and put
    them together.

    :param spikeLists: list of 2D numpy.arrays, each 2D numpy.array has the nueron/signla ID in the first column, and
           the spike-time in the second column. This numpy.array shold be sorted by spike time in ascending order.
    :param timeInjection: The amount of time (in secs) to add between a sequence of signals
    :param sequence: a 1D numpy.array, with the order of the sequence we wish to have
    :return: [combinedSequence, sequenceStartTime, sequenceEndTime] where 'combinedSequence' is a 2D numpy.array with
             the seauce of spikes, the other two arrays designate with the signals start and stop.
    """
    # Find the number of indices we need to gather
    indNumb = 0
    for i in range(sequence.size):
        indNumb += spikeLists[sequence[i]].shape[0]
    # Now generate the new combined seqence, not we need to annotate in a seperate array the order and times of each
    # sequence
    combinedSequence = numpy.zeros((indNumb,2))
    sequenceStartTime = numpy.zeros(sequence.size)
    sequenceEndTime = numpy.zeros(sequence.size)
    # Iteratively add all the seperate arrays together
    index = 0
    timeToAdd = 0.
    for i in range(sequence.size):
        # Grab the correct spike array
        someArray = spikeLists[sequence[i]]
        # Add the time to someArray
        someArray[:, 1] += timeToAdd + timeInjection
        # Find start and stop times
        sequenceStartTime[i] = someArray[0,1]
        sequenceEndTime[i] = someArray[-1,1]
        # Now add to the final output
        combinedSequence[index:index + someArray.shape[0], :] = someArray
        # Asjust index and increments
        index += someArray.shape[0]
        timeToAdd = someArray[-1, 1]
    return [combinedSequence, sequenceStartTime, sequenceEndTime]


def combineInputSequencesRandom(spikeLists, timeInjection=5., lengthSequence=10):
    """
    DESCRIPTION
    We may want to combine spike sequences in a very specific way. This is a generic fuction that does so. This function
    will take input that is already ready for brian (as I have been implementing it) where the basic unit is a 2d numpy
    array with each row bing a different spike. The first column has the index of the neuron/signal, and the second
    column has the spike time. These arrays should be sorted already by time in an ascending manner.

    Here we do not have a specific sequene of signals we want to use, rather we want to randomly generate this.

    :param spikeLists: list of 2D numpy.arrays, each 2D numpy.array has the nueron/signla ID in the first column, and
           the spike-time in the second column. This numpy.array shold be sorted by spike time in ascending order.
    :param timeInjection: The amount of time (in secs) to add between a sequence of signals
    :param lengthSequence: The length of the sequence we want to generate.
    :return: [combinedSequence, sequence, sequenceStartTime, sequenceEndTime]
    """
    # Generate the sequence
    numbTimeVaryingInputs = len(spikeLists)
    sequence = numpy.random.randint(0, numbTimeVaryingInputs, lengthSequence)
    # Find the number of indices we need to gather
    indNumb = 0
    for i in sequence.size:
        indNumb += spikeLists[sequence[i]].shape[0]
    # Now generate the new combined seqence, not we need to annotate in a seperate array the order and times of each
    # sequence
    combinedSequence = numpy.zeros((indNumb, 2))
    sequenceStartTime = numpy.zeros(sequence.size)
    sequenceEndTime = numpy.zeros(sequence.size)
    # Iteratively add all the seperate arrays together
    index = 0
    timeToAdd = 0.
    for i in range(sequence.size):
        # Grab the correct spike array
        someArray = spikeLists[sequence[i]]
        # Add the time to someArray
        someArray[:, 1] += timeToAdd + timeInjection
        # Find start and stop times
        sequenceStartTime[i] = someArray[0, 1]
        sequenceEndTime[i] = someArray[-1, 1]
        # Now add to the final output
        combinedSequence[index:index + someArray.shape[0], :] = someArray
        # Asjust index and increments
        index += someArray.shape[0]
        timeToAdd = someArray[-1, 1]
    return [combinedSequence, sequence, sequenceStartTime, sequenceEndTime]


########################################################################################################################
# TESTING METHDOS
########################################################################################################################
# Some the methods win.

if __name__ == "__main__":

    import random

    # TESTING convertSpikeListsToBrainInput()
    # Test 1 : a spike list of spike times
    spikeList = [] # List that will have list of spikes times
    for i in range(5):
        spikeList.append(random.random())
        if len(spikeList)>2:
            spikeList[-1] = spikeList[-1] + spikeList[-2]
    outputSpikesFormatted = convertSpikeListsToBrainInput(spikeList)
    print("\n")
    print(outputSpikesFormatted )

    # Test 2: list of lists (each sub-list is has spike times, each sub-list is a seperate signal)
    spikeList = [] # List of sub-lists, the sub-lists will have the spike times
    for i in range(2):
        subSpikeList = [] # This sub-list is supposed to represent one signal of many (other sub-lists)
        for j in range(5):
            subSpikeList.append(random.random())
            if len(subSpikeList)>2:
                subSpikeList[-1] = subSpikeList[-1] + subSpikeList[-2]
        spikeList.append(subSpikeList)
    outputSpikesFormatted = convertSpikeListsToBrainInput(spikeList)
    print("\n")
    print(outputSpikesFormatted)

    # Test 3: Two spike lists in a bigger list
    spikeList = [spikeList, spikeList, spikeList]
    outputSpikesFormatted = convertSpikeListsToBrainInput(spikeList)
    print("\n")
    print(outputSpikesFormatted)

    # Test 4: Now we want to combine 2D arrays!
    outputSpikesFormatted = convertSpikeListsToBrainInput(spikeList, combineData=True, timeInjection=5.)
    print("\n")
    print(outputSpikesFormatted)

    # Test 5: test the generation of sequences of data.
    # First generate some data
    spikeList = [] # List of sub-lists, the sub-lists will have the spike times.
    for i in range(2):
        subSpikeList = [] # This sub-list is supposed to represent one signal of many (other sub-lists)
        for j in range(5):
            subSpikeList.append(random.random())
            # Make times cummulative
            if len(subSpikeList) > 2:
                subSpikeList[-1] = subSpikeList[-1] + subSpikeList[-2]
        spikeList.append(subSpikeList)
    # Convert list of lists of sub-lists -> list of 2D numpy.arrays with the orderd spike times
    outputSpikesFormatted = convertSpikeListsToBrainInput([spikeList,spikeList])
    print("\n")
    print(outputSpikesFormatted)
    print(type(outputSpikesFormatted))
    # Now see if we can combine the sequences.
    sequence = combineInputSequencesNonRandom(outputSpikesFormatted, timeInjection=5., sequence=numpy.array([0,1,0]))
    print(sequence[0])



